// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package manager

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBook = `-- name: CreateBook :one
INSERT INTO books (title, author, year) VALUES ($1, $2, $3)
RETURNING id, title, author, year, is_borrowed
`

type CreateBookParams struct {
	Title  string
	Author string
	Year   pgtype.Int4
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, createBook, arg.Title, arg.Author, arg.Year)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Year,
		&i.IsBorrowed,
	)
	return i, err
}

const createBorrow = `-- name: CreateBorrow :one
INSERT INTO borrows (user_id, book_id, borrowed_at, returned_at) VALUES ($1, $2, $3, $4)
RETURNING id, user_id, book_id, borrowed_at, returned_at
`

type CreateBorrowParams struct {
	UserID     pgtype.Int4
	BookID     pgtype.Int4
	BorrowedAt pgtype.Timestamp
	ReturnedAt pgtype.Timestamp
}

func (q *Queries) CreateBorrow(ctx context.Context, arg CreateBorrowParams) (Borrow, error) {
	row := q.db.QueryRow(ctx, createBorrow,
		arg.UserID,
		arg.BookID,
		arg.BorrowedAt,
		arg.ReturnedAt,
	)
	var i Borrow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.ReturnedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, email) VALUES ($1, $2)
RETURNING id, name, email
`

type CreateUserParams struct {
	Name  string
	Email string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Name, arg.Email)
	var i User
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return i, err
}

const deleteBookWithId = `-- name: DeleteBookWithId :execrows
DELETE FROM books WHERE id = $1
`

func (q *Queries) DeleteBookWithId(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteBookWithId, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteBookWithTitle = `-- name: DeleteBookWithTitle :execrows
DELETE FROM books WHERE title = $1
`

func (q *Queries) DeleteBookWithTitle(ctx context.Context, title string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteBookWithTitle, title)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteBorrow = `-- name: DeleteBorrow :one
DELETE FROM borrows
WHERE book_id = $1 AND user_id = $2
RETURNING id, user_id, book_id, borrowed_at, returned_at
`

type DeleteBorrowParams struct {
	BookID pgtype.Int4
	UserID pgtype.Int4
}

func (q *Queries) DeleteBorrow(ctx context.Context, arg DeleteBorrowParams) (Borrow, error) {
	row := q.db.QueryRow(ctx, deleteBorrow, arg.BookID, arg.UserID)
	var i Borrow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.ReturnedAt,
	)
	return i, err
}

const filterUserByEmail = `-- name: FilterUserByEmail :one
SELECT id, name, email FROM users WHERE LOWER(email) = LOWER($1)
`

func (q *Queries) FilterUserByEmail(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, filterUserByEmail, lower)
	var i User
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return i, err
}

const filterUserByName = `-- name: FilterUserByName :many
SELECT id, name, email FROM users WHERE LOWER(name) = LOWER($1)
`

func (q *Queries) FilterUserByName(ctx context.Context, lower string) ([]User, error) {
	rows, err := q.db.Query(ctx, filterUserByName, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.ID, &i.Name, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooks = `-- name: ListBooks :many
SELECT id, title, author, year, is_borrowed FROM books ORDER BY id
`

func (q *Queries) ListBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.Query(ctx, listBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.IsBorrowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrows = `-- name: ListBorrows :many
SELECT id, user_id, book_id, borrowed_at, returned_at FROM borrows ORDER BY id
`

func (q *Queries) ListBorrows(ctx context.Context) ([]Borrow, error) {
	rows, err := q.db.Query(ctx, listBorrows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Borrow
	for rows.Next() {
		var i Borrow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.ReturnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email FROM users ORDER BY id
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.ID, &i.Name, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnBook = `-- name: ReturnBook :exec
UPDATE books SET is_borrowed = false WHERE id = $1
`

func (q *Queries) ReturnBook(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, returnBook, id)
	return err
}

const searchBooks = `-- name: SearchBooks :many
SELECT id, title, author, year, is_borrowed
FROM books
WHERE title ILIKE '%' || $1 || '%' OR author ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchBooks(ctx context.Context, dollar_1 pgtype.Text) ([]Book, error) {
	rows, err := q.db.Query(ctx, searchBooks, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Year,
			&i.IsBorrowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBook = `-- name: UpdateBook :one
UPDATE books
SET 
    title       = COALESCE($2, title),
    author      = COALESCE($3, author),
    year        = COALESCE($4, year),
    is_borrowed = COALESCE($5, is_borrowed)
WHERE id = $1
RETURNING id, title, author, year, is_borrowed
`

type UpdateBookParams struct {
	ID         int32
	Title      string
	Author     string
	Year       pgtype.Int4
	IsBorrowed pgtype.Bool
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, updateBook,
		arg.ID,
		arg.Title,
		arg.Author,
		arg.Year,
		arg.IsBorrowed,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Year,
		&i.IsBorrowed,
	)
	return i, err
}
